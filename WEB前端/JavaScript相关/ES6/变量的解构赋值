ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构
解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象，因为undefined和null无法转为对象，所以报错。

1.数组的解构赋值
  var a = 1;
  var b = 2;
  =>
  var [a,b] = [1,2]; //左右两边都必须为数组形式
  let [foo] = 1; // error
  完全解构和不完全解构

  解构允许设置默认值
  var [foo = true] = [];

  Attention！！！
  ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。
  var [x = 1] = [undefined];
  x // 1

  var [x = 1] = [null];
  x // null

  如果默认值是一个表达式，那么这个表达式是惰性求值的，也就是只有在用到的时候才会进行求值
  function f(){
    console.log('aaa');
  }

  let [x = f()] = []; //x 只是 指向了 f

  默认值可以引用解构赋值的其他变量，但是该变量需要先声明
  let [x=1,y=x] = []; // x=1，y=1
  let [x=y,y=1] = []; // error

2.对象的解构赋值
  不仅可以用在数组中，也可以用在对象中.
  var {a,b} = {a:"aaa",b:"bbb"};
  a // "aaa"
  b // "bbb"
  
  var {c} = {a:"aaa",b:"bbb"};
  c // undefined
  var {a:c} = {a:"aaa",b:"bbb"};
  c // "aaa"
  
  var A = {a:"aaa",b:"bbb"};
  var {a:a_, b:b_} = A
  a_ // "aaa"
  b_ // "bbb"
  
  其实，
  var {a,b} = {a:"aaa",b:"bbb"}; => var {a:a,b:b} = {a:"aaa",b:"bbb"};
  也就是说，对象的解构赋值的内部机制，是先 找到同名属性，然后再赋值给对应的变量。
  真正被复制的是后者，而不是前者。
  
  与数组一样，对象也可以使用嵌套
  var obj = {
    p: [
      "Hello",
      { y: "World" }
    ]
  };

  var { p: [x, { y }] } = obj;
  x // "Hello"
  y // "World"
  这里的p是模式，不是变量，因此不会被赋值
  
  与数组一样，也可以使用默认值(默认值的一些情况与数组一致)
  var {x, y = 5} = {x: 1};
  x // 1
  y // 5
  
  var {x = 3} = {x: undefined};
  x // 3

  var {x = 3} = {x: null};
  x // null
  
  // 报错
  var {foo: {bar}} = {baz: 'baz'}
  这里报错的原因是foo本来就是undefined，再取它的属性便会报错
  
  var x;
  {x} = {x:1} // 报错，这里javascript会把{x}解析成一个代码块，而不是解构赋值，所以报错
  var x;
  ({x} = {x:1}) // 正确，因为首先出现"("，所以避免了被解析为代码块而能进行正常解析
  PS：关于圆括号的问题
    虽然解构赋值给使用上带来一定的便利性，但是这对编译器来说，区别什么时候是模式还是表达式，并不能在解析第一个符号的时候就知道，
    而是需要解析到等号（=）的时候才能知道。
    那么如果解构赋值中出现了圆括号该如何呢？ES6规定，只要有可能导致解构的歧义，就不得使用圆括号。这也建议不要轻易在模式中使用
    圆括号。
    不可使用圆括号的情况：
      1.变量声明语句中，不能带有圆括号
        var [(a)] = [1];   // 报错
        var {x: (c)} = {}; // 报错
        var ({x: c}) = {}; // 报错
      2.函数参数中，模式不能带有圆括号，因为函数参数也属于变量声明，与1相同
        function f([(z)]) {return z;} // 报错
      3.赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中
        ({p:a}) = {p:42}          // 报错
        ([a]) = [5]               // 报错
        [({p:a}),{x:c}] = [{},{}] // 报错
    可使用圆括号的情况：
      只有一种情况，赋值语句的非模式部分，可以使用圆括号
      [(b)] = [3];            // 正确
      ({p:(d)}) = {};         // 正确
      [(parseInt.prop)] = [3];// 正确
  
3.字符串的解构赋值
  为什么字符串也可以解构赋值?
    因为这个时候字符串被转换成了一个雷子数组的对象
    const [a,b,c,d,e] = 'hello'
    const {length:len} = 'hello'

# to know more
4.数值和布尔值的解构赋值
  这两个类型在进行解构赋值时，如果等号右边是数值和布尔值,则会先转为对象。
  let {toString: s} = 123;
  s === Number.prototype.toString // true

  let {toString: s} = true;
  s === Boolean.prototype.toString // true
  数值和布尔值的包装对象都有toString属性，因此变量s都能取到值
  
  解构的过程中，如果右边的值不为对象则会先转化为对象再进行操作，但是undefined和null无法转为对象，所以一下情况会报错
  let { prop: x } = undefined; // TypeError
  let { prop: y } = null; // TypeError
5.函数的解构赋值
  
  function add([x, y]){
    return x + y;
  }

  add([1, 2]) // 3
  这里的x和y其实不是参数x和y，而是通过解构得到的x和y
  
  [[1, 2], [3, 4]].map(([a, b]) => a + b)
  以上同理
  
  也可以使用默认值
  function move({x = 0, y = 0} = {}) {
    return [x, y];
  }

  move({x: 3, y: 8}); // [3, 8]
说了这么多，那么变量的解构赋值的用途都有什么呢？
  1. 更便捷的交换两个变量的值
    在以往的变量交换中，我们可能需要一个辅助的局部变量来完成这一过程，如果交换的变量是数字的话，我们可以通过抑或法或者加减法来实现。
    但是在ES6中，这一切都迎刃而解，通过以下方式即可
    [x, y] = [y, x]
  2. 可以将函数的一组参数与变量名对应起来
    function test({x,y,z}) {}
    test({y:1,z:2,x:3})
  3. 十分方便得提取JSON数据
    为什么是十分呢？
      假设 a = {b:{c:2}}
      常规下，我们如果要获得c的值，必须a.b.c才能取到值，但是如果a的值出错令a = undefined，那么这个取值便会报错，当然我们可以这样做
      a && a.b && a.b.c // 但是，这样写起来十分令人难堪
      在ES6中，我们可以直接使用下面的语句而无须担心其他异常情况
      let {b:{c}} = a
      c // 2
    当然这个做法使用于一切需要从通过属性访问符"."获取到值或对象的方法。
  4. 函数参数的默认值
    这个用法也是在实际使用中比较实用的一个方法
    ES5中
      function test(a,b){
        a = a || 0;
        b = b || 0;
      }
    ES6中
      解构赋值的做法
        function test({a = 0, b = 0}){}
        foo({})
      一般做法
        function test(a = 0, b = 0) {}
        foo()
      
    相比之下，优点也是显而易见的。
